<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        .map {
            width: 500px;
            height: 100vh;
            border: 1px solid;
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            background-color: #2d5a27;
            overflow: hidden;
        }

        .road {
            position: absolute;
            width: 100%;
            height: 200%;
            background: 
                /* 중앙 흰색 도로 */
                linear-gradient(90deg, 
                    #2d5a27 0%, 
                    #2d5a27 25%, 
                    #ffffff 25%, 
                    #ffffff 75%, 
                    #2d5a27 75%, 
                    #2d5a27 100%
                ),
                /* 노란색 구분 차선 */
                linear-gradient(90deg, 
                    transparent 0%, 
                    transparent 49.5%, 
                    #ffff00 49.5%, 
                    #ffff00 50.5%, 
                    transparent 50.5%, 
                    transparent 100%
                ),
                /* 세로 차선 */
                repeating-linear-gradient(
                    0deg,
                    #2d5a27 0px,
                    #2d5a27 50px,
                    #ffffff 50px,
                    #ffffff 100px
                );
            top: -50%;
            transition: top 0.1s linear;
        }

        .background {
            position: absolute;
            width: 100%;
            height: 200%;
            top: -50%;
            transition: none;
        }

        .tree {
            position: absolute;
            width: 20px;
            height: 40px;
            background: #228B22;
            border-radius: 50% 50% 0 0;
        }

        .tree::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 15px;
            background: #8B4513;
        }

        .mountain {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 30px solid transparent;
            border-right: 30px solid transparent;
            border-bottom: 60px solid #696969;
        }

        .cloud {
            position: absolute;
            width: 40px;
            height: 20px;
            background: #ffffff;
            border-radius: 20px;
        }

        .cloud::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 10px;
            width: 20px;
            height: 20px;
            background: #ffffff;
            border-radius: 50%;
        }

        .cloud::after {
            content: '';
            position: absolute;
            top: -5px;
            right: 10px;
            width: 15px;
            height: 15px;
            background: #ffffff;
            border-radius: 50%;
        }

        .obstacle {
            width: 15px;
            height: 30px;
            border: 1px solid;
            position: absolute;
            transition: none;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 300px;
            text-align: center;
            border-radius: 10px;
        }

        .game-over {
            font-size: 48px;
            color: #ff0000;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .restart-btn {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        .restart-btn:hover {
            background-color: #45a049;
        }

        .map>.myCar {
            width: 15px;
            height: 30px;
            border: 1px solid;
            background-color: red;
            position: absolute;
            left: calc(50% - 7.5px);
            top: calc(50% - 15px);
            transition: .3s;
        }
    </style>
</head>

<body>

    <button onClick="poppi.sound()">뽀삐 짖어!</button>
    <hr />
    <h1>MY CAR</h1>
    소유자 :<input id="owner" /><br />
    차종 :<input id="cat" /><br />
    연료타입 : <input id="fuelType" /><br />
    <button id="save">저장하기</button>
    <hr />
    <button onClick="myCar.accel()">가속</button>
    <button onClick="myCar.break()">감속</button>
    <button onClick="myCar.toString()">상태확인</button>
    <h2>대시보드</h2>
    <div style="display: flex; gap: 20px; margin-bottom: 10px;">
        <div style="background: #f0f0f0; padding: 10px; border-radius: 5px;">
            <strong>시간:</strong> <span id="game-time">00:00:00</span>
        </div>
        <div style="background: #f0f0f0; padding: 10px; border-radius: 5px;">
            <strong>통과:</strong> <span id="passed-count">0대</span>
        </div>
        <div style="background: #f0f0f0; padding: 10px; border-radius: 5px;">
            <strong>레벨:</strong> <span id="current-level">1</span>
        </div>
    </div>
    <div id="gauge" style="transition:.5s; height:50px;width:0;background-color: orange;"></div>

    <div class="map">
        <div class="road"></div>
        <div class="background">
            <!-- 왼쪽 배경 요소들 -->
            <div class="tree" style="left: 10%; top: 20%;"></div>
            <div class="tree" style="left: 15%; top: 60%;"></div>
            <div class="tree" style="left: 8%; top: 80%;"></div>
            <div class="mountain" style="left: 5%; top: 10%;"></div>
            <div class="cloud" style="left: 5%; top: 5%;"></div>
            
            <!-- 오른쪽 배경 요소들 -->
            <div class="tree" style="right: 10%; top: 30%;"></div>
            <div class="tree" style="right: 15%; top: 70%;"></div>
            <div class="tree" style="right: 8%; top: 90%;"></div>
            <div class="mountain" style="right: 5%; top: 15%;"></div>
            <div class="cloud" style="right: 10%; top: 8%;"></div>
            
            <!-- 추가 배경 요소들 -->
            <div class="tree" style="left: 20%; top: 40%;"></div>
            <div class="tree" style="right: 20%; top: 50%;"></div>
            <div class="cloud" style="left: 30%; top: 3%;"></div>
            <div class="cloud" style="right: 25%; top: 12%;"></div>
        </div>
        <div id="obstacles-container"></div>
        <div class="myCar"></div>
    </div>

    <!-- GAME OVER 모달 -->
    <div id="gameOverModal" class="modal">
        <div class="modal-content">
            <div class="game-over">GAME OVER</div>
            <div id="score-display" style="font-size: 24px; margin: 20px 0; color: #333;"></div>
            <button class="restart-btn" onclick="restartGame()">다시 시작</button>
        </div>
    </div>
    <script>

        //MyCar :속성 : 소유자,속도,연료량,차종,연료타입....
        const myCar = {
            // 속성
            owner: "",
            cat: "",
            fuleType: "",
            speed: 0,
            fuelAmout: 100,
            positionX: '7.5',
            positionY: '15',
            moveValue: '10',
            // 기능
            accel: function () {
                this.speed = this.speed + 10;
                console.log("가속처리완료 현재속도 : ", this.speed);

                const gaugeEl = document.getElementById('gauge');
                gaugeEl.style.width = `${this.speed * 2}px`;
            },
            break: function () {
                this.speed = this.speed - 10;
                console.log("감속처리완료 현재속도 : ", this.speed);

                const gaugeEl = document.getElementById('gauge');
                gaugeEl.style.width = `${this.speed * 2}px`;
            },
            toString: function () {
                console.log(this.owner, this.cat, this.fuleType, this.speed, this.fuelAmout);
            }
        }

        const saveBtn = document.getElementById('save');
        saveBtn.addEventListener('click', () => {
            const ownerInputEl = document.getElementById('owner');
            const catInputEl = document.getElementById('cat');
            const fuleTypeInputEl = document.getElementById('fuelType');
            // console.log('save btn clicked..',ownerInputEl.value,catInputEl.value,fuleTypeInputEl.value);
            myCar.owner = ownerInputEl.value;
            myCar.cat = catInputEl.value;
            myCar.fuleType = fuleTypeInputEl.value;
            console.log('save btn clicked..myCarInfo : ', myCar);
        });


  

        // ---
        function createObstacle() {
            const obstacle = document.createElement('div');
            obstacle.className = 'obstacle';
            
            // 랜덤 색상 배열
            const colors = [
                '#0000FF', // 파란색
                '#00FF00', // 초록색
                '#FFFF00', // 노란색
                '#FF00FF', // 마젠타
                '#00FFFF', // 시안
                '#FFA500', // 주황색
                '#800080', // 보라색
                '#008000', // 다크그린
                '#000080', // 네이비
                '#FFC0CB'  // 핑크
            ];
            
            // 랜덤 색상 선택
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            obstacle.style.backgroundColor = randomColor;
            
            // 랜덤 X 위치 (도로 영역 내에서) - 겹치지 않도록 체크
            const roadLeft = 25; // 도로 시작 위치 (%)
            const roadRight = 75; // 도로 끝 위치 (%)
            let randomX;
            let attempts = 0;
            const maxAttempts = 50;
            
            do {
                randomX = roadLeft + Math.random() * (roadRight - roadLeft - 5);
                attempts++;
            } while (isObstacleOverlapping(randomX) && attempts < maxAttempts);
            
            // 최대 시도 횟수를 초과하면 생성하지 않음
            if (attempts >= maxAttempts) {
                return;
            }
            
            obstacle.style.left = `${randomX}%`;
            obstacle.style.top = '-30px'; // 화면 위에서 시작
            
            // 레벨에 따른 랜덤 속도 (1~3 + 레벨 보너스)
            const baseSpeed = 1 + Math.random() * 2;
            const levelBonus = (currentLevel - 1) * 1.0; // 레벨당 1.0씩 증가 (더 빠르게)
            const speed = baseSpeed + levelBonus;
            
            const obstacleData = {
                element: obstacle,
                x: randomX,
                y: -30,
                speed: speed
            };
            
            obstacles.push(obstacleData);
            document.getElementById('obstacles-container').appendChild(obstacle);
        }

        function isObstacleOverlapping(newX) {
            // 새로운 장애물이 기존 장애물과 겹치는지 확인
            const minDistance = 8; // 최소 거리 (%)
            
            for (let obstacle of obstacles) {
                const distance = Math.abs(obstacle.x - newX);
                if (distance < minDistance) {
                    return true; // 겹침
                }
            }
            return false; // 겹치지 않음
        }

        function updateObstacles() {
            if (!gameRunning) return;
            
            const currentTime = Date.now();
            const gameTime = (currentTime - gameStartTime) / 1000; // 게임 시간 (초)
            
            // 레벨에 따라 장애물 생성 간격 조절 (더 극적으로)
            let minInterval = Math.max(200, 2500 - (currentLevel - 1) * 200); // 레벨당 200ms씩 감소
            let maxInterval = Math.max(400, 3500 - (currentLevel - 1) * 250); // 레벨당 250ms씩 감소
            
            // 랜덤하게 장애물 생성 (레벨에 따라 여러 개 생성)
            if (currentTime - lastObstacleTime > minInterval + Math.random() * (maxInterval - minInterval)) {
                // 레벨에 따라 생성할 장애물 수 결정
                let obstacleCount;
                if (currentLevel <= 2) {
                    obstacleCount = 5; // 레벨 1-2: 5개
                } else if (currentLevel <= 5) {
                    obstacleCount = 10; // 레벨 3-5: 10개
                } else if (currentLevel <= 8) {
                    obstacleCount = 15; // 레벨 6-8: 15개
                } else {
                    obstacleCount = 20; // 레벨 9-10: 20개
                }
                
                for (let i = 0; i < obstacleCount; i++) {
                    // 약간의 지연을 두고 생성 (겹치지 않도록)
                    setTimeout(() => {
                        if (gameRunning) {
                            createObstacle();
                        }
                    }, i * 200); // 200ms 간격으로 생성
                }
                
                lastObstacleTime = currentTime;
            }
            
            // 기존 장애물들 업데이트
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.y += obstacle.speed;
                obstacle.element.style.top = `${obstacle.y}px`;
                
                // 충돌 감지
                if (checkCollision(obstacle)) {
                    gameOver();
                    return;
                }
                
                // 화면 밖으로 나간 장애물 제거 및 카운트 증가
                if (obstacle.y > window.innerHeight) {
                    obstacle.element.remove();
                    obstacles.splice(i, 1);
                    passedObstacles++; // 통과한 장애물 수 증가
                }
            }
        }

        function checkCollision(obstacle) {
            // 자동차와 장애물의 충돌 감지
            const carLeft = myCar.positionX;
            const carRight = myCar.positionX + 15;
            const carTop = myCar.positionY;
            const carBottom = myCar.positionY + 30;
            
            // 장애물의 실제 픽셀 위치 계산
            const mapWidth = 500;
            const obstacleLeft = (obstacle.x / 100) * mapWidth;
            const obstacleRight = obstacleLeft + 15;
            const obstacleTop = obstacle.y;
            const obstacleBottom = obstacle.y + 30;
            
            // 충돌 검사
            return !(carLeft > obstacleRight || 
                    carRight < obstacleLeft || 
                    carTop > obstacleBottom || 
                    carBottom < obstacleTop);
        }

        function gameOver() {
            gameRunning = false;
            
            // 점수 표시
            const gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
            const scoreDisplay = document.getElementById('score-display');
            scoreDisplay.innerHTML = `
                <div>통과한 장애물: <strong>${passedObstacles}대</strong></div>
                <div>생존 시간: <strong>${gameTime}초</strong></div>
            `;
            
            document.getElementById('gameOverModal').style.display = 'block';
        }

        function restartGame() {
            // 모든 장애물 제거
            obstacles.forEach(obstacle => obstacle.element.remove());
            obstacles = [];
            
            // 게임 상태 초기화
            gameRunning = true;
            gameStartTime = Date.now();
            passedObstacles = 0;
            currentLevel = 1;
            myCar.speed = 0;
            myCar.positionX = 250;
            myCar.positionY = window.innerHeight - 30;
            
            // 모달 숨기기
            document.getElementById('gameOverModal').style.display = 'none';
            
            // 게이지 초기화
            document.getElementById('gauge').style.width = '0px';
            
            // 키 상태 초기화
            keysPressed = {};
            
            // 애니메이션 재시작
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            animateCar();
        }

        function updateDashboard() {
            // 시간 업데이트
            const gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
            const hours = Math.floor(gameTime / 3600);
            const minutes = Math.floor((gameTime % 3600) / 60);
            const seconds = gameTime % 60;
            const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('game-time').textContent = timeString;
            
            // 통과한 장애물 수 업데이트
            document.getElementById('passed-count').textContent = `${passedObstacles}대`;
            
            // 레벨 업데이트
            document.getElementById('current-level').textContent = currentLevel;
        }

        function updateLevel() {
            const gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
            const newLevel = Math.min(10, Math.floor(gameTime / 15) + 1);
            
            if (newLevel !== currentLevel) {
                currentLevel = newLevel;
                // 레벨 업 시 효과 (선택사항)
                console.log(`레벨 업! 현재 레벨: ${currentLevel}`);
            }
        }

        function updateGauge() {
            const gaugeEl = document.getElementById('gauge');

            // 어떤 방향키라도 눌려있으면 가속
            if (keysPressed['ArrowUp'] || keysPressed['ArrowDown'] || keysPressed['ArrowLeft'] || keysPressed['ArrowRight']) {
                // 가속 중 → 속도 증가 (최대 250까지, 게이지 500px)
                if (myCar.speed < 250) {
                    myCar.speed += 2;
                }
            } else {
                // 감속 상태 → 속도 서서히 감소
                if (myCar.speed > 0) {
                    myCar.speed -= 1;
                }
            }

            // 최소값 보정
            if (myCar.speed < 0) myCar.speed = 0;

            // 게이지 너비를 속도에 비례하게 설정 (최대 500px)
            gaugeEl.style.width = `${myCar.speed * 2}px`;
        }

        // ---
        let keysPressed = {}; // 어떤 키가 눌려있는지 저장
        let animationId = null; // 애니메이션 루프 ID
        let obstacles = []; // 장애물 배열
        let lastObstacleTime = 0; // 마지막 장애물 생성 시간
        let gameRunning = true; // 게임 실행 상태
        let gameStartTime = Date.now(); // 게임 시작 시간
        let passedObstacles = 0; // 통과한 장애물 수
        let currentLevel = 1; // 현재 레벨
        document.addEventListener('keydown', function (e) {
            keysPressed[e.code] = true;
            if (!animationId) {
                animateCar();
            }
        });

        document.addEventListener('keyup', function (e) {
            keysPressed[e.code] = false;

            // 모든 키가 떼졌어도 게이지 감소를 위해 애니메이션은 계속 실행
            if (!animationId) {
                animateCar();
            }
        });

        //DOMLOAD 이벤트 추가(처음 자동차의 위치 지정)
        document.addEventListener('DOMContentLoaded', function () {
            const myCarEl = document.querySelector('.myCar')
            myCar.positionX = 250; // 가로 중앙 위치
            myCar.positionY = window.innerHeight - 30; // 제일 아래 (자동차 높이 고려)
            myCar.moveValue = 10;
            myCar.direction = 0; // 초기 방향 (0도)
            myCarEl.style.left = `${myCar.positionX}px`;
            myCarEl.style.top = `${myCar.positionY}px`;

            myCarEl.style.transform = `rotate(${myCar.direction}deg)`; // 초기 회전
        })
        //KEYDOWN 이벤트 추가
        function animateCar() {
            if (!gameRunning) return;
            
            const myCarEl = document.querySelector('.myCar');
            const roadEl = document.querySelector('.road');
            const backgroundEl = document.querySelector('.background');

            if (keysPressed['ArrowUp']) {
                // 자동차 Y 위치는 고정 (항상 아래쪽)
                myCar.positionY = window.innerHeight - 30;
                myCar.direction = 0;
                
                // 속도에 따라 배경 움직임 속도 조절
                const speedMultiplier = myCar.speed / 250; // 0~1 사이 값
                const moveSpeed = myCar.moveValue * (0.5 + speedMultiplier * 0.5);
                
                // 도로가 위에서 아래로 움직이는 효과
                const currentTop = parseFloat(roadEl.style.top) || -50;
                const newTop = currentTop + moveSpeed;
                roadEl.style.top = `${newTop}%`;
                
                // 배경도 함께 움직이는 효과 (속도에 따라 조절)
                backgroundEl.style.top = `${newTop}%`;
                
                // 도로와 배경이 끝까지 가면 처음으로 리셋
                if (newTop >= 0) {
                    roadEl.style.top = '-50%';
                    backgroundEl.style.top = '-50%';
                }
            } else {
                // 키를 떼면 속도에 따라 천천히 배경 움직임
                if (myCar.speed > 0) {
                    const speedMultiplier = myCar.speed / 250; // 0~1 사이 값
                    const moveSpeed = myCar.moveValue * (0.1 + speedMultiplier * 0.2); // 더 천천히
                    
                    const currentTop = parseFloat(roadEl.style.top) || -50;
                    const newTop = currentTop + moveSpeed;
                    roadEl.style.top = `${newTop}%`;
                    backgroundEl.style.top = `${newTop}%`;
                    
                    // 도로와 배경이 끝까지 가면 처음으로 리셋
                    if (newTop >= 0) {
                        roadEl.style.top = '-50%';
                        backgroundEl.style.top = '-50%';
                    }
                }
            }
            if (keysPressed['ArrowDown']) {
                myCar.positionY += myCar.moveValue;
                myCar.direction = 180;
            }
            if (keysPressed['ArrowLeft']) {
                myCar.positionX -= myCar.moveValue;
                myCar.direction = -90;
            }
            if (keysPressed['ArrowRight']) {
                myCar.positionX += myCar.moveValue;
                myCar.direction = 90;
            }

            // .map 영역을 벗어나지 못하도록 위치 제한
            // 자동차 크기: 15px x 30px
            const carWidth = 15;
            const carHeight = 30;
            const mapWidth = 500;
            const mapHeight = window.innerHeight;

            // X축 제한 (0 ~ mapWidth - carWidth)
            if (myCar.positionX < 0) myCar.positionX = 0;
            if (myCar.positionX > mapWidth - carWidth) myCar.positionX = mapWidth - carWidth;

            // Y축 제한 (0 ~ mapHeight - carHeight)
            if (myCar.positionY < 0) myCar.positionY = 0;
            if (myCar.positionY > mapHeight - carHeight) myCar.positionY = mapHeight - carHeight;

            myCarEl.style.left = `${myCar.positionX}px`;
            myCarEl.style.top = `${myCar.positionY}px`;
            myCarEl.style.transform = `rotate(${myCar.direction}deg)`;

            updateObstacles();
            updateGauge();
            updateDashboard();
            updateLevel();
            
            // 게이지가 0이 되면 애니메이션 중지
            if (myCar.speed <= 0 && !Object.values(keysPressed).includes(true)) {
                cancelAnimationFrame(animationId);
                animationId = null;
            } else {
                animationId = requestAnimationFrame(animateCar);
            }
        }

    </script>


</body>

</html>